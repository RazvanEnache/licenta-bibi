import Sequelize from "sequelize";
import nodemailer from "nodemailer";
import bcrypt, { hash } from "bcrypt";
import jwt from "jsonwebtoken";

//Mailing
const transporter = nodemailer.createTransport({
	service: "hotmail",
	auth: {
		user: "transport-23@outlook.com",
		pass: "transport22",
	},
});

function valid(Model, payload) {
	return Object.entries(Model.tableAttributes).reduce((valid, [name, field]) => {
		if (valid && !field._autoGenerated && !field.primaryKey && field.allowNull === false && !payload[name]) {
			valid = false;
		}
		return valid;
	}, true);
}

function attributes(request) {
	if (request.headers["x-fields"]) {
		return request.headers["x-fields"].split(",");
	} else {
		return undefined;
	}
}

function where(request) {
	if (request.query.filter) {
		return request.query.filter.split(",").reduce((filter, condition) => {
			let data = condition.split("/");
			filter[data[0]] = { [Sequelize.Op[data[1]]]: data[2] };

			console.log(filter);
			return filter;
		}, {});
	} else {
		return undefined;
	}
}

function order(request) {
	if (request.headers["x-sort"]) {
		return request.headers["x-sort"].split(",").reduce((sort, field) => {
			sort.push([field.substring(1), field.charAt(0) === "+" ? "ASC" : "DESC"]);
			return sort;
		}, []);
	} else {
		return undefined;
	}
}

//getRecords, postRecord, deleteRecords,
//getRecord, headRecord, putRecord, patchRecord, deleteRecord
const handleLogout = async (Model, req, res) => {
	// On client, also delete the accessToken

	const cookies = req.cookies;
	if (!cookies?.jwt) return res.sendStatus(204); //No content
	const refreshToken = cookies.jwt;

	// Is refreshToken in db?
	const foundUser = await Model.findOne({ where: { refreshToken: refreshToken } });
	if (!foundUser) {
		res.clearCookie("jwt", { httpOnly: true, sameSite: "None", secure: true });
		return res.sendStatus(204);
	}

	// Delete refreshToken in db
	foundUser.refreshToken = "";
	const result = await foundUser.save();
	console.log(result);

	res.clearCookie("jwt", { httpOnly: true, sameSite: "None", secure: true });
	res.sendStatus(204);
};

const handleRefreshToken = async (Model, req, res) => {
	const cookies = req.cookies;
	if (!cookies?.jwt) return res.sendStatus(401);
	const refreshToken = cookies.jwt;

	const foundUser = await Model.findOne({ where: { refreshToken: refreshToken } });
	if (!foundUser) return res.sendStatus(403); //Forbidden
	// evaluate jwt
	jwt.verify(refreshToken, process.env.REFRESH_TOKEN_SECRET, (err, decoded) => {
		if (err || foundUser.user !== decoded.user) return res.sendStatus(403);
		const roles = foundUser.roles;
		const accessToken = jwt.sign(
			{
				UserInfo: {
					user: decoded.user,
					roles: roles,
				},
			},
			process.env.ACCESS_TOKEN_SECRET,
			{ expiresIn: "1d" }
		);
		res.json({ roles, accessToken, user: foundUser.user, userObj: foundUser });
	});
};

async function registerUser(Model, request, response) {
	const { user, pwd } = request.body;
	if (!user || !pwd) return response.status(400).json({ message: "Username and password are required." });

	// check for duplicate usernames in the db
	const duplicate = await Model.findOne({ where: { user: user } });
	if (duplicate) return response.sendStatus(409); //Conflict

	try {
		//encrypt the password
		const hashedPwd = await bcrypt.hash(pwd, 10);

		//create and store the new user
		const result = await Model.create({ ...request.body, pwd: hashedPwd });

		console.log(result);

		response.status(201).json({ success: `New user ${user} created!` });
	} catch (error) {
		response.status(500).json(error);
	}
}

async function authUser(Model, request, response) {
	try {
		const { user, pwd } = request.body;
		if (!user || !pwd) return response.status(400).json({ message: "Username and password are required." });

		const foundUser = await Model.findOne({ where: { user: user } });

		if (!foundUser) return response.status(401).send(); //Unauthorized
		// evaluate password
		const match = await bcrypt.compare(pwd, foundUser.pwd);

		if (match) {
			// create JWTs
			const roles = foundUser.roles;
			const user = foundUser.user;

			const accessToken = jwt.sign(
				{
					UserInfo: {
						user: foundUser.user,
						roles: foundUser.roles,
					},
				},
				process.env.ACCESS_TOKEN_SECRET,
				{ expiresIn: "1d" }
			);
			const refreshToken = jwt.sign({ user: foundUser.user }, process.env.REFRESH_TOKEN_SECRET, { expiresIn: "1d" });
			// Saving refreshToken with current user
			foundUser.refreshToken = refreshToken;
			const result = await foundUser.save();

			// Creates Secure Cookie with refresh token
			response.cookie("jwt", refreshToken, { httpOnly: true, secure: true, sameSite: "None", maxAge: 24 * 60 * 60 * 1000 });

			// Send authorization roles and access token to user
			response.json({ roles, accessToken, user, userObj: foundUser });
		} else {
			response.status(401).send();
		}
	} catch (error) {
		response.status(500).json(error);
	}
}

async function getRecords(Model, request, response) {
	try {
		let records = await Model.findAll({
			attributes: attributes(request),
			order: order(request),
			where: where(request),
		});
		if (records.length > 0) {
			response.status(200).json(records);
		} else {
			response.status(204).send([]);
		}
	} catch (error) {
		response.status(500).json(error);
	}
}

async function postRecord(Model, request, response) {
	try {
		if (valid(Model, request.body)) {
			let record = await Model.create(request.body);
			response
				.status(201)
				.location(
					`http://${request.headers.host}${request.baseUrl}${request.url}${request.url.endsWith("/") ? "" : "/"}${record.id}`
				)
				.json(record);
		} else {
			response.status(400).send();
		}
	} catch (error) {
		response.status(500).json(error);
	}
}

async function deleteRecords(Model, request, response) {
	try {
		await Model.truncate();
		response.status(204).send();
	} catch (error) {
		response.status(500).json(error);
	}
}

async function getRecord(Model, request, response) {
	try {
		let record = await Model.findByPk(request.params.id, {
			attributes: attributes(request),
		});
		if (record) {
			response.status(200).json(record);
		} else {
			response.status(404).send();
		}
	} catch (error) {
		response.status(500).json(error);
	}
}

async function headRecord(Model, request, response) {
	try {
		response.status((await Model.findByPk(request.params.id)) ? 204 : 404).send();
	} catch (error) {
		response.status(500).json(error);
	}
}

async function putRecord(Model, request, response) {
	try {
		let record = await Model.findByPk(request.params.id);
		console.log;
		if (record) {
			if (valid(Model, request.body)) {
				await record.update(request.body);
				response.status(204).send();
			} else {
				response.status(400).send();
			}
		} else {
			response.status(404).send();
		}
	} catch (error) {
		response.status(500).json(error);
	}
}

async function patchRecord(Model, request, response) {
	try {
		let record = await Model.findByPk(request.params.id);
		if (record) {
			Object.entries(request.body).forEach(([name, value]) => (record[name] = value));
			await record.save();
			response.status(204).send();
		} else {
			response.status(404).send();
		}
	} catch (error) {
		response.status(500).json(error);
	}
}

async function deleteRecord(Model, request, response) {
	try {
		let record = await Model.findByPk(request.params.id);
		if (record) {
			await record.destroy();
			response.status(204).send();
		} else {
			response.status(404).send();
		}
	} catch (error) {
		response.status(500).json(error);
	}
}

async function sendMail(request, response) {
	try {
		transporter.sendMail(request.body, (err, info) => {
			if (err) {
				console.log(err);
				return;
			}
			console.log(info.response);
		});
	} catch (error) {
		response.status(500).json(error);
	}
}

export {
	getRecords,
	postRecord,
	deleteRecords,
	getRecord,
	headRecord,
	putRecord,
	patchRecord,
	deleteRecord,
	sendMail,
	authUser,
	registerUser,
	handleRefreshToken,
	handleLogout,
};
